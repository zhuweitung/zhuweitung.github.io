

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://fastly.img.kedr.cc/a894a628cfd6b9bb778f156b6efeb26b.png">
  <link rel="icon" href="https://fastly.img.kedr.cc/a894a628cfd6b9bb778f156b6efeb26b.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="zhuweitung">
  <meta name="keywords" content="">
  
    <meta name="description" content="JUC并发编程知识学习及查漏补缺">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC并发编程知识学习及查漏补缺">
<meta property="og:url" content="https://blog.kedr.cc/posts/3956405114/index.html">
<meta property="og:site_name" content="个人随笔">
<meta property="og:description" content="JUC并发编程知识学习及查漏补缺">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fastly.img.kedr.cc/5c1f7e9edb873dbd9a1d3eb049469912.png">
<meta property="article:published_time" content="2022-03-19T09:43:48.000Z">
<meta property="article:modified_time" content="2024-04-21T04:23:15.083Z">
<meta property="article:author" content="zhuweitung">
<meta property="article:tag" content="java">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://fastly.img.kedr.cc/5c1f7e9edb873dbd9a1d3eb049469912.png">
  
  
  
  <title>JUC并发编程知识学习及查漏补缺 - 个人随笔</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.kedr.cc","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#96be66","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"f2550b082b1ec518a726847e5f27e3c4","google":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Rnyy6d3kzXonmFTiXC2DM2wM-gzGzoHsz","app_key":"ItzHQLPR4iIXylU6VCqf1j4f","server_url":"https://rnyy6d3k.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"gtag":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?f2550b082b1ec518a726847e5f27e3c4";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>个人随笔</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://raw.gitmirror.com/zhuweitung/bing-wallpaper/main/wallpaper/day1_1080.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JUC并发编程知识学习及查漏补缺"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-19 17:43" pubdate>
          2022年3月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          154 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JUC并发编程知识学习及查漏补缺</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="下载OpenJDK源码"><a class="header-anchor" href="#下载OpenJDK源码"></a>下载OpenJDK源码</h3>
<p>并发包中很多类底层都是native方法，为了更好的理解需要去阅读jdk的源代码（c++）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/releases/tag/jdk8-b120">jdk8-b120下载地址</a></p>
<h3 id="Thread启动原理"><a class="header-anchor" href="#Thread启动原理"></a>Thread启动原理</h3>
<p>线程启动调用的是线程对象的<code>start</code>方法，而start方法中调用了一个native的<code>start0</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>    group.add(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        start0();<br>        started = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!started) &#123;<br>                group.threadStartFailed(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>openjdk写的JNI一般是一一对应的，Thread.java对应的就是<code>Thread.c</code></p>
<p>start0对应的是<code>JVM_StartThread</code></p>
<p><img src="https://fastly.img.kedr.cc/992f6f37fd7d384ebbb2c873805d341a.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>在<code>jvm.cpp</code>中搜索JVM_StartThread，发现最终调用<code>Thread::start</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">JVM_ENTRY</span>(<span class="hljs-type">void</span>, <span class="hljs-built_in">JVM_StartThread</span>(JNIEnv* env, jobject jthread))<br>  <span class="hljs-built_in">JVMWrapper</span>(<span class="hljs-string">&quot;JVM_StartThread&quot;</span>);<br>  JavaThread *native_thread = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-comment">// ...</span><br><br>  Thread::<span class="hljs-built_in">start</span>(native_thread);<br><br>JVM_END<br></code></pre></td></tr></table></figure>
<p>在<code>thread.cpp</code>文件中找到方法，底层是调用操作系统层去开启线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::start</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;<br>  <span class="hljs-built_in">trace</span>(<span class="hljs-string">&quot;start&quot;</span>, thread);<br>  <span class="hljs-keyword">if</span> (!DisableStartThread) &#123;<br>    <span class="hljs-keyword">if</span> (thread-&gt;<span class="hljs-built_in">is_Java_thread</span>()) &#123;<br>      java_lang_Thread::<span class="hljs-built_in">set_thread_status</span>(((JavaThread*)thread)-&gt;<span class="hljs-built_in">threadObj</span>(),<br>                                          java_lang_Thread::RUNNABLE);<br>    &#125;<br>    os::<span class="hljs-built_in">start_thread</span>(thread);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="一锁两并三程"><a class="header-anchor" href="#一锁两并三程"></a>一锁两并三程</h3>
<h4 id="一锁"><a class="header-anchor" href="#一锁"></a>一锁</h4>
<p>synchronized</p>
<h4 id="两并"><a class="header-anchor" href="#两并"></a>两并</h4>
<ul>
<li>并发：一个处理器同时处理多个任务</li>
<li>并行：多个处理器同时处理多个任务</li>
</ul>
<h4 id="三程"><a class="header-anchor" href="#三程"></a>三程</h4>
<ul>
<li>进程：系统中运行的一个应用程序就是一个进程，每个进程都有自己的内存空间和系统资源</li>
<li>线程：在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元</li>
<li>管程：监视器（Monitor），也就是平时说的锁，是一种同步机制</li>
</ul>
<h3 id="Future"><a class="header-anchor" href="#Future"></a>Future</h3>
<p>Future接口定义了操作异步任务一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等</p>
<p><em>一句话：Future接口可以为主线程开一个分支任务，专门为主线程处理耗时费力的复杂业务</em></p>
<h4 id="FutureTask"><a class="header-anchor" href="#FutureTask"></a>FutureTask</h4>
<p>三个特点：多线程、有返回值、异步任务</p>
<p>常用的多线程实现方式，如继承Thread、实现Runnable接口都没有返回值；实现Callable接口可以有返回值，但是又没法放到Thread的构造方法中，而FutureTask类实现了Runnable接口又包含一个注入Callable对象的构造方法，通过实现Callable接口再经过FutureTask包装后来创建Thread就可以解决此问题。</p>
<p><img src="https://fastly.img.kedr.cc/70403777916b85a3eafb1609eec6385f.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h5 id="使用示例"><a class="header-anchor" href="#使用示例"></a>使用示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTaskDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BuyWaterThread</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br>        <span class="hljs-comment">// 阻塞等待线程执行完成，获取返回值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> futureTask.get();<br>		log.info(<span class="hljs-string">&quot;喝到&#123;&#125;了&quot;</span>, s);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyWaterThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">10</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;水&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Future优缺点"><a class="header-anchor" href="#Future优缺点"></a>Future优缺点</h4>
<h5 id="优点"><a class="header-anchor" href="#优点"></a>优点</h5>
<p>future+线程池异步多线程任务配合，能显著提升程序的执行效率</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; taskDurations = Arrays.asList(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>);<br>    <span class="hljs-type">TimeInterval</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> DateUtil.timer();<br>    m1(taskDurations, timer); <span class="hljs-comment">// 多任务依次执行耗时 1021 ms</span><br>    m2(taskDurations, timer); <span class="hljs-comment">// 多任务异步执行耗时 535 ms</span><br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">(List&lt;Integer&gt; taskDurations, TimeInterval timer)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">for</span> (Integer taskDuration : taskDurations) &#123;<br>        Thread.sleep(taskDuration);<br>    &#125;<br>    log.info(<span class="hljs-string">&quot;多任务依次执行耗时 &#123;&#125; ms&quot;</span>, timer.intervalRestart());<br>&#125;<br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">(List&lt;Integer&gt; taskDurations, TimeInterval timer)</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>    List&lt;FutureTask&lt;String&gt;&gt; tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Integer taskDuration : taskDurations) &#123;<br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(taskDuration);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> taskDuration.toString();<br>        &#125;);<br>        tasks.add(task);<br>        threadPool.submit(task);<br>    &#125;<br>    threadPool.shutdown();<br>    <span class="hljs-keyword">for</span> (FutureTask&lt;String&gt; task : tasks) &#123;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, task.get());<br>    &#125;<br>    log.info(<span class="hljs-string">&quot;多任务异步执行耗时 &#123;&#125; ms&quot;</span>, timer.intervalRestart());<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="缺点"><a class="header-anchor" href="#缺点"></a>缺点</h5>
<ul>
<li>get方法阻塞
<ul>
<li>调用get(long timeout, TimeUnit unit)方法，设置超时时间，超时后会抛出异常，一定程度上缓解阻塞</li>
<li>轮询调用isDone方法，判断任务状态是否为完成，轮询会耗费无谓的CPU资源；若想要异步获取结果，通常还是以此方式，尽量不要阻塞</li>
</ul>
</li>
</ul>
<h3 id="CompletableFuture"><a class="header-anchor" href="#CompletableFuture"></a>CompletableFuture</h3>
<p>对于Future的缺点，希望进行异步处理是可以传入回调函数，在Future结束时自动调用该回调函数，这样就不用阻塞，也不用去轮询判断了</p>
<p>JDK8设计出CompletableFuture，提供了一种观察者模式类似的机制</p>
<p><img src="https://fastly.img.kedr.cc/7168fca955882927a379a6cf16ee8ada.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="CompletionStage接口"><a class="header-anchor" href="#CompletionStage接口"></a>CompletionStage接口</h4>
<ul>
<li>CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段</li>
<li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li>
</ul>
<p><img src="https://fastly.img.kedr.cc/350dfe37a40571b191a6a948fdae415a.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="创建对象"><a class="header-anchor" href="#创建对象"></a>创建对象</h4>
<p>一般通过核心的四个静态方法来创建</p>
<ul>
<li>runAsync(Runnable runnable)：无返回值</li>
<li>runAsync(Runnable runnable, Executor executor)：无返回值，使用线程池</li>
<li>supplyAsync(Supplier&lt;U&gt; supplier)：有返回值</li>
<li>supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)：有返回值，使用线程池</li>
<li>若没有指定线程池，直接使用默认的ForkJoinPool.commonPool()作为它的线程池去执行异步代码</li>
</ul>
<h4 id="示例代码"><a class="header-anchor" href="#示例代码"></a>示例代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        CompletableFuture.supplyAsync(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;in &#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current().nextInt(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">1</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//num = num / 0;</span><br>            <span class="hljs-keyword">return</span> num;<br>        &#125;, threadPool).whenComplete((v, e) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                log.info(<span class="hljs-string">&quot;get value &#123;&#125;&quot;</span>, v);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.error(<span class="hljs-string">&quot;发生异常 &#123;&#125;&quot;</span>, e.getMessage(), e);<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        threadPool.shutdown();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;主线程执行&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>并行查询图书价格</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;WebMall&gt; webMalls = Arrays.asList(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMall</span>(<span class="hljs-string">&quot;jd&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMall</span>(<span class="hljs-string">&quot;taobao&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMall</span>(<span class="hljs-string">&quot;pdd&quot;</span>)<br>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getPriceByCompletableFuture</span><span class="hljs-params">(String bookName)</span> &#123;<br>    <span class="hljs-type">TimeInterval</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> DateUtil.timer();<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>    List&lt;String&gt; prices = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// List&lt;WebMall&gt; -&gt; List&lt;CompletableFuture&gt; -&gt; List&lt;String&gt;</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        prices = webMalls.stream()<br>                .map(w -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;<br>                    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s in %s price is %.2f&quot;</span>, bookName, w.getName(), w.queryBookPrice(bookName));<br>                &#125;, threadPool))<br>                .collect(Collectors.toList())<br>                .stream()<br>                .map(c -&gt; c.join())<br>                .collect(Collectors.toList());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        threadPool.shutdown();<br>    &#125;<br>    prices.stream().forEach(System.out::println);<br>    log.info(<span class="hljs-string">&quot;耗时 &#123;&#125; ms&quot;</span>, timer.intervalRestart());<br>    <span class="hljs-keyword">return</span> prices;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="常用方法"><a class="header-anchor" href="#常用方法"></a>常用方法</h4>
<h5 id="获取结果和触发计算"><a class="header-anchor" href="#获取结果和触发计算"></a>获取结果和触发计算</h5>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>get()</td>
<td>需要抛出异常</td>
</tr>
<tr>
<td>get(long timeout, TimeUnit unit)</td>
<td>设置等待超时时间，超时后抛出异常</td>
</tr>
<tr>
<td>join()</td>
<td>不需要排除异常</td>
</tr>
<tr>
<td>getNow(T valueIfAbsent)</td>
<td>立即获取结果，不阻塞；调用时若没有没有处理完成，则返回传入的valueIfAbsent，否则返回处理结果</td>
</tr>
<tr>
<td>complete(T value)</td>
<td>调用时若没有没有处理完成，则返回true，并打断get/join方法立即返回括号值，否则返回false</td>
</tr>
</tbody>
</table>
<h5 id="对计算结果进行处理"><a class="header-anchor" href="#对计算结果进行处理"></a>对计算结果进行处理</h5>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>thenApply</td>
<td>对计算结果存在依赖关系，这两个线程串行化;使用同一个线程;出现异常后，不再进行下一步</td>
</tr>
<tr>
<td>thenApplyAsync</td>
<td>与thenApply的区别在于，从线程池中取一个线程</td>
</tr>
<tr>
<td>handle</td>
<td>与thenApply的区别在于，出现异常后仍然会执行下一步</td>
</tr>
<tr>
<td>handleAsync</td>
<td>与thenApplyAsync的区别在于，出现异常后仍然会执行下一步</td>
</tr>
</tbody>
</table>
<p>后缀为<code>Async</code>的处理方法都是从线程池中取线程，若没有传入自定义线程池，都用默认线程池<code>ForkJoinPool</code>，下面不再赘述</p>
<p><em>有可能处理太快，系统优化切换原则，直接使用main线程处理</em></p>
<h5 id="对计算结果进行消费"><a class="header-anchor" href="#对计算结果进行消费"></a>对计算结果进行消费</h5>
<p>接收任务的处理结果，并消费处理，无返回结果</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>thenRun(Runnable action)</td>
<td>不管上一步的结果</td>
</tr>
<tr>
<td>thenAccept(Consumer action)</td>
<td>处理上一步的结果，没有返回值</td>
</tr>
<tr>
<td>thenApply(Function fn)</td>
<td>处理上一步的结果，有返回值</td>
</tr>
</tbody>
</table>
<h5 id="对计算速度进行选用"><a class="header-anchor" href="#对计算速度进行选用"></a>对计算速度进行选用</h5>
<ul>
<li>applyToEither：哪个任务先处理完，用哪个任务的处理结果</li>
</ul>
<h5 id="对计算结果进行合并"><a class="header-anchor" href="#对计算结果进行合并"></a>对计算结果进行合并</h5>
<ul>
<li>thenCombine：将两个任务的处理结果一起交给thenCombine处理</li>
</ul>
<h4 id="优点-v2"><a class="header-anchor" href="#优点-v2"></a>优点</h4>
<ul>
<li>异步任务结束时，会自动回调某个对象的方法</li>
<li>主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行</li>
<li>异步任务出错时，会自动回调某个对象的方法</li>
</ul>
<h3 id="乐观锁和悲观锁"><a class="header-anchor" href="#乐观锁和悲观锁"></a>乐观锁和悲观锁</h3>
<h4 id="乐观锁"><a class="header-anchor" href="#乐观锁"></a>乐观锁</h4>
<p>乐观锁认为自己在使用数据的时候不会有其他线程修改数据，所以不会添加锁，不加锁的特点能够使其读操作的性能大幅提升，适合读多的场景</p>
<p>Java中使用无锁编程来实现，只是在更新数据的时候去判断，在本次更新操作之前有没有其他线程更新了数据，若没有被更新过，则当前线程将自己修改的数据成功写入，否则根据不同的实现方法执行不同的操作，如放弃修改、重试枪锁等</p>
<p>常见的实现方式有：</p>
<ul>
<li>版本号机制Version</li>
<li>最常用的<code>CAS算法</code>，Java原子类中的递增操作就通过CAS自旋实现</li>
</ul>
<h4 id="悲观锁"><a class="header-anchor" href="#悲观锁"></a>悲观锁</h4>
<p>悲观锁认为自己在使用数据的时候一定有其他线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改；比较严格，更耗性能</p>
<p><code>synchronized关键字</code>和<code>Lock的实现类</code>都是悲观锁</p>
<p>适合于写操作多的场景，先加锁确保写操作时数据正确</p>
<h3 id="synchronized原理解析"><a class="header-anchor" href="#synchronized原理解析"></a>synchronized原理解析</h3>
<h4 id="同步代码块"><a class="header-anchor" href="#同步代码块"></a>同步代码块</h4>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;m1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译为字节码后使用 <code>javap -c xxx.class</code>命令查看信息</p>
<p><img src="https://fastly.img.kedr.cc/ca0c2e9ae62ce3291999202fb26d4bf5.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>可见同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>指令实现</p>
<p>一般情况下是1个monitorenter和2个monitorexit指令，但是当代码块内手动抛出异常时会只有1个monitorenter和1个monitorexit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;m1&quot;</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://fastly.img.kedr.cc/7a1902b673e53309d50cbca4469a8d95.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="同步方法"><a class="header-anchor" href="#同步方法"></a>同步方法</h4>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;m1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译为字节码后使用 <code>javap -v xxx.class</code>命令查看更详细信息</p>
<p><img src="https://fastly.img.kedr.cc/88b0cc6192a237fb4ff751e435f5de7a.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>会加一个<code>ACC_SYNCHRONIZED</code>标志，程序执行时判断有此标志时，执行线程会先持有monitor锁，然后再执行方法，最后在方法完成（正常或异常）时释放monitor锁</p>
<h4 id="静态同步方法"><a class="header-anchor" href="#静态同步方法"></a>静态同步方法</h4>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;m1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://fastly.img.kedr.cc/8c87eaec894ff13229365797aa4544b1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><code>ACC_STATIC</code>标志将同步方法与静态同步方法区分开</p>
<h4 id="monitor"><a class="header-anchor" href="#monitor"></a>monitor</h4>
<p>monitor被称为管程或者监视器，是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。Java虚拟机调用方法时，将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，若设置了，执行线程就要求先成功持有管程，然后才能执行方法，当方法实现完成时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到统一个管程。</p>
<p>Java的monitor在源码中采用ObjectMonitor实现</p>
<p>ObjectMonitor.java -&gt; objectMonitor.cpp -&gt; objectMonitor.hpp</p>
<p><img src="https://fastly.img.kedr.cc/0ecd0438f5d12ed12c4e1f4e1d941509.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>每个对象天生都带一个对象监视器，每一个被锁住的对象都会和monitor关联起来，所有任何一个对象都可以成为一个锁</p>
<h3 id="公平锁和非公平锁"><a class="header-anchor" href="#公平锁和非公平锁"></a>公平锁和非公平锁</h3>
<p>公平锁是指多个线程按照申请锁的顺序来获取锁，类似排队，先来的排前面，这是公平的；</p>
<p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，后申请的线程肯能比先申请的线程优先获得锁，类似于插队，在高并发环境下，可能造成优先级翻转或者线程饥饿情况（某个线程一直拿不到锁）</p>
<p><code>new ReentrantLock()</code>是非公平锁，<code>new ReentrantLock(true)</code>是公平锁</p>
<h4 id="为什么默认非公平锁"><a class="header-anchor" href="#为什么默认非公平锁"></a>为什么默认非公平锁</h4>
<ul>
<li>
<p>恢复挂起的线程到真正获取锁是有时间差的，非公平锁能更加充分地利用CPU时间片，尽量减少CPU空闲状态时间</p>
</li>
<li>
<p>线程的切换会造成额外的开销</p>
</li>
</ul>
<h4 id="公平锁和非公平锁的使用场景"><a class="header-anchor" href="#公平锁和非公平锁的使用场景"></a>公平锁和非公平锁的使用场景</h4>
<ul>
<li>为了更高的吞吐量，使用非公平锁比较合适</li>
<li>否则就用公平锁</li>
</ul>
<h3 id="可重入锁"><a class="header-anchor" href="#可重入锁"></a>可重入锁</h3>
<p>可重入锁又被称为递归锁，是指在<code>同一个线程</code>在外层获取锁的时候，再进入线程的内层方法会自动获取锁，不会因为之前已经获取过没释放而阻塞；在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</p>
<p><code>ReentrantLock</code>和<code>synchronized关键字</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁</p>
<h4 id="隐式锁"><a class="header-anchor" href="#隐式锁"></a>隐式锁</h4>
<p>synchronized关键字所使用的锁</p>
<h4 id="显式锁"><a class="header-anchor" href="#显式锁"></a>显式锁</h4>
<p>ReentrantLock，使用时lock与unlock要一一配对</p>
<h4 id="synchronized的重入实现原理"><a class="header-anchor" href="#synchronized的重入实现原理"></a>synchronized的重入实现原理</h4>
<p>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针</p>
<p>当执行monitorenter时，若目标锁对象的计数器为0，说明它没有被其他线程所持有，Java虚拟机将该锁对象的持有线程指针指向当前线程，并将计数器加1</p>
<p>当目标锁对象的计数器不为0时，若锁对象的持有线程为当前线程，Java虚拟机将计数器加1，否则当前线程需要等待锁对象的持有线程释放该锁（计数器变为0）</p>
<p>当执行monitorexit时，Java虚拟机将锁对象的计数器减1，为0表示锁已被释放</p>
<h3 id="死锁及排查"><a class="header-anchor" href="#死锁及排查"></a>死锁及排查</h3>
<h4 id="死锁产生的原因"><a class="header-anchor" href="#死锁产生的原因"></a>死锁产生的原因</h4>
<ul>
<li>系统资源不足</li>
<li>进程运行顺序不合适</li>
<li>资源分配不当</li>
</ul>
<h4 id="死锁的排查"><a class="header-anchor" href="#死锁的排查"></a>死锁的排查</h4>
<p><code>jps -l</code>命令查看java进程</p>
<p><code>jstack 进程号</code>查看进程堆栈信息</p>
<p><img src="https://fastly.img.kedr.cc/fe48d6f9005538638722a7ab7e314861.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>或者使用<code>jconsole</code>可视化的方式查看</p>
<p><img src="https://fastly.img.kedr.cc/93fa907ffd6258c14ed7c3168365623d.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="LockSupport与线程中断"><a class="header-anchor" href="#LockSupport与线程中断"></a>LockSupport与线程中断</h3>
<h4 id="中断机制"><a class="header-anchor" href="#中断机制"></a>中断机制</h4>
<p>一个线程不应该由其他线程来强制中断或停止，应该由线程自己自行停止；</p>
<p>Java提供一种用于停止线程的<code>协商机制</code>–中断，也即中断标识协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。若要中断一个线程，需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true。需要自己写代码不断检测当前线程的标识位，若为true，表示别的线程请求中断当前线程，收到请求后怎么处理需要自己写代码实现。</p>
<h5 id="中断相关API方法"><a class="header-anchor" href="#中断相关API方法"></a>中断相关API方法</h5>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void interrupt()</td>
<td>将线程的中断标识位设置为true，发起一个协商而不会立即停止线程</td>
</tr>
<tr>
<td>static boolean interrupted()</td>
<td>判断线程是否被中断并清除当前中断状态；做了两件事：1、返回当前线程的中断状态，测试当前线程是否已被中断 2、将当前线程的中断标识位重置为false，清除线程的中断状态</td>
</tr>
<tr>
<td>boolean isInterrupted()</td>
<td>判断当前线程是否被中断（通过检查中断标识位）</td>
</tr>
</tbody>
</table>
<h5 id="如何停止中断运行中的线程"><a class="header-anchor" href="#如何停止中断运行中的线程"></a>如何停止中断运行中的线程</h5>
<ul>
<li>
<p>通过volatile变量实现，volatile关键字保证变量在多线程间的可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">keepRunning</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptByVolatile</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">if</span> (!keepRunning) &#123;<br>                log.info(<span class="hljs-string">&quot;&#123;&#125; 暂停运行&quot;</span>, Thread.currentThread().getName());<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; 发出停止请求&quot;</span>, Thread.currentThread().getName());<br>        keepRunning = <span class="hljs-literal">false</span>;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>通过AtomicBoolean变量实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">keepRunning2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptByAtomic</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">if</span> (!keepRunning2.get()) &#123;<br>                log.info(<span class="hljs-string">&quot;&#123;&#125; 暂停运行&quot;</span>, Thread.currentThread().getName());<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; 发出停止请求&quot;</span>, Thread.currentThread().getName());<br>        keepRunning2.set(<span class="hljs-literal">false</span>);<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>通过线程的中断标识位实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptByThreadInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (; ; ) &#123;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                log.info(<span class="hljs-string">&quot;&#123;&#125; 暂停运行&quot;</span>, Thread.currentThread().getName());<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; 发出停止请求&quot;</span>, Thread.currentThread().getName());<br>        t1.interrupt();<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="源码解读"><a class="header-anchor" href="#源码解读"></a>源码解读</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> != Thread.currentThread())<br>        checkAccess();<br>    <span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br>        <span class="hljs-type">Interruptible</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> blocker;<br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>            interrupt0();           <span class="hljs-comment">// 调用native方法设置中断标识位</span><br>            b.interrupt(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    interrupt0();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt0</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> isInterrupted(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 调用native方法判断是否中断，不清除标识位</span><br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">(<span class="hljs-type">boolean</span> ClearInterrupted)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interrupted</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> currentThread().isInterrupted(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 清除标识位</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用interrupt方法时：</p>
<p>如果该线程阻塞的调用<code>wait()</code> ， <code>wait(long)</code> ，或<code>wait(long, int)</code>的方法Object类，或的join() ， <code>join(long)</code> ， <code>join(long, int)</code> ， <code>sleep(long)</code> ，或<code>sleep(long, int)</code> ，这个类的方法，那么它的中断状态将被清除，并且将收到<code>InterruptedException</code> 。</p>
<p>中断不活动的线程不会产生任何影响。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptSleep</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                log.info(<span class="hljs-string">&quot;&#123;&#125; 中断&quot;</span>, Thread.currentThread().getName());<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.error(<span class="hljs-string">&quot;发生 InterruptedException&quot;</span>);<br>                <span class="hljs-comment">// 此处需手动终止循环或者调用线程中断，否则就死循环了</span><br>                <span class="hljs-comment">// 因为发生InterruptedException时线程的中断状态会被清除，即标识位变为false</span><br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">2</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    t1.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="LockSupport"><a class="header-anchor" href="#LockSupport"></a>LockSupport</h4>
<p>LockSupport用于创建锁和其他同步类的基本线程阻塞原语；</p>
<p>该类与使用它的每个线程关联一个许可证（在<code>Semaphore</code>类的意义上）。 如果许可证可用，将立即返回<code>park</code> ，并在此过程中消费; 否则<em>可能会</em>阻止。 如果尚未提供许可，则致电<code>unpark</code>获得许可。 （与Semaphores不同，许可证不会累积。<code>最多只有一个</code>，即一个park对应一个unpark，不能在调用park后且调用unpark前再次调用park。）</p>
<p>主要有<code>park</code>和<code>unpark</code>方法，作用分别是阻塞线程和解除阻塞线程</p>
<h5 id="线程等待和唤醒方式"><a class="header-anchor" href="#线程等待和唤醒方式"></a>线程等待和唤醒方式</h5>
<ul>
<li>
<p>使用<code>Object</code>的<code>wait</code>方法让线程等待，使用<code>notify</code>方法唤醒线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitNotify</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;&#123;&#125; 被唤醒&quot;</span>, Thread.currentThread().getName());<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">2</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            obj.notify();<br>        &#125;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>obj对象必须是有锁的才能调用wait和notify方法</li>
<li>wait和notify方法的调用顺序必须是先wait后notify</li>
</ul>
</li>
<li>
<p>使用<code>JUC</code>包中的<code>Condition</code>的<code>await</code>方法让线程等待，使用<code>signal</code>方法唤醒线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitSignal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.await();<br>            log.info(<span class="hljs-string">&quot;&#123;&#125; 被唤醒&quot;</span>, Thread.currentThread().getName());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">2</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>必须要先获得锁才能调用await和signal方法</li>
<li>await和signal方法的调用顺序必须是先await后signal</li>
</ul>
</li>
<li>
<p>使用<code>LockSupport</code>的<code>park</code>方法让线程等待，使用<code>unpark</code>方法唤醒线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUnPark</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        LockSupport.park();<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; 被唤醒&quot;</span>, Thread.currentThread().getName());<br>    &#125;);<br>    t1.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">2</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        LockSupport.unpark(t1);<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>方法调用没有锁的要求</li>
<li>可以先唤醒后等待（先把许可证发给线程，线程中调用park后不会阻塞，直接通过）</li>
<li>底层是调用<code>Unsafe</code>类的方法</li>
</ul>
</li>
</ul>
<h3 id="Java内存模型JMM"><a class="header-anchor" href="#Java内存模型JMM"></a>Java内存模型JMM</h3>
<p>Java内存模型（JMM，Java Memory Model）与JVM（Java虚拟机）不是一个概念！</p>
<p>CPU的运行并不是直接操作内存，而是先把内存里的数据读到CPU的缓存（二级或三级缓存），而内存的读写操作时就会造成不一致的问题。JVM规范中试图定义一种Java内存模型来<code>屏蔽掉各种硬件和操作系统的内存访问差异</code>，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>JMM是一种抽象的概念，仅仅描述一组约定或规范，这组规范定义了程序中各个变量的读写访问方式，并决定一个线程对共享变量的写入时机以及何如对另一个线程可见，关键技术点都是围绕多线程<code>的原子性、可见性和有序性</code>展开的。</p>
<h4 id="三大特性"><a class="header-anchor" href="#三大特性"></a>三大特性</h4>
<ul>
<li>
<p>原子性：一个操作不能被打断，要么全部执行完毕，要么不执行</p>
</li>
<li>
<p>可见性：指当一个线程修改某一个变量时，其他线程是否能够立即知道变更</p>
<ul>
<li>JMM规定了所有的变量都存储在<code>主内存</code>中</li>
<li>线程不能直接修改主内存中的变量，线程修改变量时会先创建一个主内存中<code>变量的副本</code>保存到线程自己的<code>工作内存</code>中，其他线程无法访问本线程工作内存中的变量副本，线程间变量的传递都需要通过主内存来完成</li>
<li>除了volatile关键字能实现可见性之外，还有synchronized，Lock，final也是可以的</li>
</ul>
</li>
<li>
<p>有序性：一般习惯性认为代码总是从上到下有序执行，但其他底层为了提升性能，编译器和处理器通常会对指令序列进行重新排序（<code>指令重排</code>）。Java规范规定JVM线程内部维持<code>顺序化语义</code>，即只要程序的最终结果与它顺序执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令重排。</p>
<ul>
<li>优点是能够使机器指令更符合CPU的执行特性，最大限度的发挥机器性能</li>
<li>缺点是指令重排可以保证<code>串行</code>语义一致，但<code>无法保证多线程间的语义也一致</code>，可能导致线程脏读出现</li>
</ul>
</li>
</ul>
<h4 id="happens-before"><a class="header-anchor" href="#happens-before"></a>happens-before</h4>
<p>happens-before即先行发生原则。如果一个操作执行的结果需要对另一个操作可见或代码重排序，那么这两个操作之间必须存在happens-before原则。</p>
<h5 id="总原则"><a class="header-anchor" href="#总原则"></a>总原则</h5>
<ul>
<li>若一个操作先行发生于另一个操作，那么第一操作的执行结果将对第二个操作可见，且第一个操作的执行顺序排在第二个操作之前</li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行；若重排序之后的执行结果与按照happens-before关系来执行的<code>结果一致</code>，那么这种重排序并不非法</li>
</ul>
<h5 id="八条规则"><a class="header-anchor" href="#八条规则"></a>八条规则</h5>
<ul>
<li>次序规则：<code>在一个线程内</code>，按照代码顺序，写在前面的操作先行发生于写在后面的操作，也就是说前面一步操作的结果能被后续操作获取</li>
<li>锁定规则：一个unlock操作<code>先行发生</code>于后面（时间上的先后）对同一个锁的lock操作</li>
<li>volatile变量规则：对一个volatile变量的<code>写操作先行发生</code>于后面（时间上的先后）对这个变量的读操作，也就是说前面的写对后面的读是可见的</li>
<li>传递规则：若操作A先行发生于操作B，操作B先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start方法先行发生于此现场的每一个动作</li>
<li>线程中断规则：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生，也就是说先设置中断标识位，才能检测到中断事件</li>
<li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过isAlive等方法检测线程是否已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize方法的开始</li>
</ul>
<h3 id="volatile与JMM"><a class="header-anchor" href="#volatile与JMM"></a>volatile与JMM</h3>
<p>被volatile修饰的变量有2大特点，<code>可见性</code>和<code>有序性</code>（禁止指令重排）</p>
<p>volatile的内存语义：</p>
<ul>
<li>当对一个volatile变量进行写操作时，JMM会把该线程对应的本地内存中的共享变量值<code>立即刷新回主内存</code>中</li>
<li>当对一个volatile变量进行读操作时，JMM会把该线程对应的本地内存中的共享变量值设置为无效，重新回到主内存中读取最新的共享变量值</li>
<li>总结：写操作立即刷新到主内存，读操作是直接从主内存读取</li>
</ul>
<p>volatile依靠<code>内存屏障</code>保证可见性和有序性</p>
<h4 id="内存屏障"><a class="header-anchor" href="#内存屏障"></a>内存屏障</h4>
<p>内存屏障是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。JMM的重排序规则会要求Java编译器在生成JVM指令时<code>插入特定的内存屏障指令</code>，通过这些内存屏障指令，volatile实现了JMM中的可见性和有序性（禁重排），但是volatile<code>无法保障原子性</code>。</p>
<p><code>内存屏障之前</code>的所有<code>写操作</code>都要回写到主内存</p>
<p><code>内存屏障之后</code>的所有<code>读操作</code>都能获得内存屏障之前的所有写操作的最新结果（实现了可见性）</p>
<h5 id="内存屏障分类"><a class="header-anchor" href="#内存屏障分类"></a>内存屏障分类</h5>
<p>粗分为2种：</p>
<ul>
<li>读屏障（load barrier）：在读指令之前插入读屏障，让工作内存中的缓存数据失效，重新回到主内存中获取最新数据</li>
<li>写屏障（store barrier）：在写指令之后插入写屏障，强制把工作内存（缓冲区）中的数据写回到主内存中</li>
</ul>
<p><code>Unsafe</code>类中关于屏障的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读屏障</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFence</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 写屏障</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">storeFence</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 全屏障，即读写屏障</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fullFence</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p>对应jdk源码中的Unsafe.java -&gt; unsafe.cpp -&gt; orderAccess.hpp</p>
<p><img src="https://fastly.img.kedr.cc/1f7e105dc286521fe130332eaa587297.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>细分为4种：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad</td>
<td>Load1;LoadLoad;Load2</td>
<td>保证load1的读取操作在load2及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1;StoreStore;Store2</td>
<td>在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1;LoadStore;Store2</td>
<td>在store2及其后的写操作执行前，保证load1的读操作已读取结束</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1;StoreLoad;Load2</td>
<td>在store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td>
</tr>
</tbody>
</table>
<h4 id="volatile变量规则"><a class="header-anchor" href="#volatile变量规则"></a>volatile变量规则</h4>
<table>
<thead>
<tr>
<th>第一个操作</th>
<th>第二个操作：普通读写</th>
<th>第二个操作：volatile读</th>
<th>第二个操作：volatile写</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通读写</td>
<td>可以重排</td>
<td>可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile读</td>
<td>不可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile写</td>
<td>可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
</tbody>
</table>
<ul>
<li>volatile读之后的操作，都禁止重排序到volatile之前</li>
<li>volatile写之前的操作，都禁止重排序到volatile之后</li>
<li>volatile写之后volatile读，禁止重排序</li>
</ul>
<h4 id="volatile读插入内存屏障"><a class="header-anchor" href="#volatile读插入内存屏障"></a>volatile读插入内存屏障</h4>
<p>读屏障：</p>
<ul>
<li>
<p>在volatile读操作后面插入一个LoadLoad屏障，禁止将此volatile读与后面的普通读重排序</p>
</li>
<li>
<p>在volatile读操作后面插入一个LoadStore屏障，禁止将此volatile读与后面的普通写重排序</p>
</li>
</ul>
<p><img src="https://fastly.img.kedr.cc/35b6f672ebd50ce40e6ab1a02c00e1c5.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>写屏障：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障，保证在volatile写之前，其前面锁头普通写操作已经刷新到主内存中</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障，避免volatile写与后面可能有的volatile读/写操作重排序</li>
</ul>
<p><img src="https://fastly.img.kedr.cc/56ec33cab6ec74fe937b37b7e679db94.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="volatile变量读写过程"><a class="header-anchor" href="#volatile变量读写过程"></a>volatile变量读写过程</h4>
<p>Java内存模型中定义的8种工作内存与主内存之间的原子操作：</p>
<p>read(读取) -&gt; load(加载) -&gt; use(使用)-&gt; assign(赋值) -&gt; store(存储) -&gt; write(写入) -&gt; lock(锁定)-&gt; unlock(解锁)</p>
<ul>
<li>
<p>read：作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存</p>
</li>
<li>
<p>load：作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</p>
</li>
<li>
<p>use：作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</p>
</li>
<li>
<p>assign：作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</p>
</li>
<li>
<p>store：作用于工作内存，将赋值完毕的工作变量的值写回给主内存</p>
</li>
<li>
<p>write：作用于主内存，将store传输过来的变量值赋值给主内存中的变量</p>
</li>
</ul>
<p>由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令:</p>
<ul>
<li>
<p>lock：作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</p>
</li>
<li>
<p>unlock：作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</p>
</li>
</ul>
<p><img src="https://fastly.img.kedr.cc/a7241e267dc222660419cb845997456f.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="volatile的最佳实践"><a class="header-anchor" href="#volatile的最佳实践"></a>volatile的最佳实践</h4>
<p>volatile变量不适合参与到依赖当前值的运算，如i=i+1,；i++等</p>
<p>依靠volatile的可见性特点，通常volatile用于保存某个状态的boolean值或int值</p>
<p>当volatile变量不符合以下两条时，需要加锁来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
<p>最佳实践：</p>
<ul>
<li>单一赋值，但复合运算不可以（i++之类）</li>
<li>状态标志，判断业务是否结束</li>
<li>开销较低的读（读保证可见性不加锁，写需要加锁来保证原子性）</li>
<li>DCL双重校验锁（Double Check Lock）</li>
</ul>
<h3 id="CAS"><a class="header-anchor" href="#CAS"></a>CAS</h3>
<p>CAS（Compare And Swap），实现并发算法时常用的一种技术</p>
<p>它包含三个操作数：内存位置、预期原值和更新值</p>
<p>在执行CAS操作时，将内存位置的值与预期原值比较：若相匹配，处理器将该内存位置的值更新为新值；若不匹配，处理将不做任何操作或重试（这种重试行为被称为<code>自旋</code>），多个线程同时执行CAS操作只有一个会成功</p>
<h4 id="硬件级别保证"><a class="header-anchor" href="#硬件级别保证"></a>硬件级别保证</h4>
<p>CAS是JDK提供的<code>非阻塞原子性</code>操作，它通过硬件保证了比较-更新的原子性</p>
<p>CAS是一条CPU的原子指令（<code>cmpxchg</code>），不会造成数据不一致问题，<code>Unsafe</code>提供的CAS方法（compareAndSwapInt等）底层实现即为CPU指令cmpxchg。CAS的原子性是CPU实现独占的，比起synchronized重量级锁，CAS的排他时间要短很多，所以在多线程情况下性能会比较好。</p>
<h4 id="Unsafe类"><a class="header-anchor" href="#Unsafe类"></a>Unsafe类</h4>
<p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存。</p>
<p>java.util.concurrent.atomic包中类的方法基本都是调用Unsafe类的方法实现的</p>
<p>AtomicInteger类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取value变量值在内存中的偏移地址</span><br>        valueOffset = unsafe.objectFieldOffset<br>            (AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用volatile修改，保证变量的可见性</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Unsafe类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4, <span class="hljs-type">int</span> var5)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2); <span class="hljs-comment">// 获取内存偏移位置上的原值</span><br>        <span class="hljs-comment">// 比较并更新，若不匹配就自旋</span><br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="AtomicReference"><a class="header-anchor" href="#AtomicReference"></a>AtomicReference</h4>
<p>java.util.concurrent.atomic包下提供了AtomicReference类，可以将我们需要的任何对象包装进去称为原子类</p>
<h4 id="CAS与自旋锁"><a class="header-anchor" href="#CAS与自旋锁"></a>CAS与自旋锁</h4>
<p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式取尝试获取锁，当线程发现锁被占用时，会不断判断锁的状态，直到获取，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>
<p>实现自旋锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (!locked.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>        <span class="hljs-comment">// 若是上锁状态就自旋</span><br>    &#125;<br>    log.info(<span class="hljs-string">&quot;&#123;&#125; 上锁&quot;</span>, Thread.currentThread().getName());<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (!locked.compareAndSet(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)) &#123;<br>        <span class="hljs-comment">// 若是未上锁状态就自旋</span><br>    &#125;<br>    log.info(<span class="hljs-string">&quot;&#123;&#125; 解锁&quot;</span>, Thread.currentThread().getName());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">2</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        unlock();<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">2</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        unlock();<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="CAS缺点"><a class="header-anchor" href="#CAS缺点"></a>CAS缺点</h4>
<ul>
<li>
<p>循环时间长开销很大</p>
</li>
<li>
<p>会出现ABA问题</p>
<ul>
<li>
<p>线程1从内存位置V取出A，同时线程2也从内存中取出A，并且线程2进行操作将值变为了B，然后又进行操作将V位置的数据变为了A，此时线程1进行CAS操作时发现内存中依然是A，CAS操作成功</p>
</li>
<li>
<p>虽然线程1操作成功，但不代表这个过程没有问题</p>
</li>
<li>
<p>要解决ABA问题可以使用版本号（version）/戳记（AtomicStampedReference）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> reference.getReference();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> reference.getStamp();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">1</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        reference.compareAndSet(num, <span class="hljs-number">101</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">1</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        reference.compareAndSet(<span class="hljs-number">101</span>, num, stamp + <span class="hljs-number">1</span>, stamp + <span class="hljs-number">2</span>);<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> reference.getReference();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> reference.getStamp();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">3</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;compareAndSet &#123;&#125;&quot;</span>, reference.compareAndSet(num, <span class="hljs-number">102</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="原子操作类"><a class="header-anchor" href="#原子操作类"></a>原子操作类</h3>
<p><img src="https://fastly.img.kedr.cc/b7932c9b081ecb0064cc748b7c61e6b6.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="分类"><a class="header-anchor" href="#分类"></a>分类</h4>
<p>基本类型原子类：</p>
<ul>
<li>AtomicInteger</li>
<li>AtomicBoolean</li>
<li>AtomicLong</li>
</ul>
<p>数组类型原子类：</p>
<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<p>引用类型原子类：</p>
<ul>
<li>AtomicReference</li>
<li>AtomicStampedReference：携带版本号的引用类型原子类，可以解决ABA问题，记录修改次数</li>
<li>AtomicMarkableReference：原子更新时会更改标记位，标记是否修改过</li>
</ul>
<p>对象属性修改原子类：</p>
<ul>
<li>
<p>AtomicIntegerFieldUpdater：基于反射，对指定类的指定volatile int 字段进行原子更新</p>
</li>
<li>
<p>AtomicLongFieldUpdater：基于反射，对指定类的指定volatile long 字段进行原子更新</p>
</li>
<li>
<p>AtomicReferenceFieldUpdater：基于反射，对指定类的指定volatile 引用类型字段进行原子更新</p>
</li>
<li>
<p>使用目的：以线程安全的方式操作非线程安全对象内的某些字段</p>
</li>
<li>
<p>使用要求</p>
<ul>
<li>进行操作的属性需要求<code>public volatile</code>关键字修饰</li>
<li>使用静态方法newUpdater创建一个更新器，并设置需要更新的类和属性</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Increment</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    AtomicIntegerFieldUpdater&lt;Increment&gt; updater = <br>        AtomicIntegerFieldUpdater.newUpdater(Increment.class, <span class="hljs-string">&quot;value&quot;</span>);<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">Increment</span> <span class="hljs-variable">increment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Increment</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;自增&quot;</span>);<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        threadPool.submit(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    updater.incrementAndGet(increment);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                count.countDown();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    threadPool.shutdown();<br>    count.await();<br>    log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, increment);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>原子操作增强类：</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator：使用给定的累加器函数和初始值创建新实例</li>
<li>LongAdder：创建一个初始总和为0的新加法器；当多个线程更新用于收集统计信息但不用于细粒度同步控制的目的公共和时，此类通常优于AtomicLong，在低更新争用下，两个类具有相似特征，但在高争用情况下，本类的预期吞吐量明显更高，但代价是空间消耗更多</li>
</ul>
<p>性能比较示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LikeClick</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>((a, b) -&gt; a + b, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickBySynchronized</span><span class="hljs-params">()</span> &#123;<br>        number++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByAtomicLong</span><span class="hljs-params">()</span> &#123;<br>        atomicLong.getAndIncrement();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAdder</span><span class="hljs-params">()</span> &#123;<br>        longAdder.increment();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAccumulator</span><span class="hljs-params">()</span> &#123;<br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LikeClick</span> <span class="hljs-variable">likeClick</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LikeClick</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">clickNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">50</span>);<br><span class="hljs-type">TimeInterval</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> DateUtil.timer();<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>    threadPool.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; clickNum; j++) &#123;<br>                likeClick.clickBySynchronized();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            count1.countDown();<br>        &#125;<br>    &#125;);<br>&#125;<br>count1.await();<br>log.info(<span class="hljs-string">&quot;clickBySynchronized 结果：&#123;&#125; 耗时&#123;&#125;ms&quot;</span>, likeClick.getNumber(), timer.intervalRestart());<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">count2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>    threadPool.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; clickNum; j++) &#123;<br>                likeClick.clickByAtomicLong();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            count2.countDown();<br>        &#125;<br>    &#125;);<br>&#125;<br>count2.await();<br>log.info(<span class="hljs-string">&quot;clickByAtomicLong 结果：&#123;&#125; 耗时&#123;&#125;ms&quot;</span>, likeClick.getAtomicLong(), timer.intervalRestart());<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">count3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>    threadPool.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; clickNum; j++) &#123;<br>                likeClick.clickByLongAdder();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            count3.countDown();<br>        &#125;<br>    &#125;);<br>&#125;<br>count3.await();<br>log.info(<span class="hljs-string">&quot;clickByLongAdder 结果：&#123;&#125; 耗时&#123;&#125;ms&quot;</span>, likeClick.getLongAdder(), timer.intervalRestart());<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">count4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>    threadPool.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; clickNum; j++) &#123;<br>                likeClick.clickByLongAccumulator();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            count4.countDown();<br>        &#125;<br>    &#125;);<br>&#125;<br>count4.await();<br>log.info(<span class="hljs-string">&quot;clickByLongAccumulator 结果：&#123;&#125; 耗时&#123;&#125;ms&quot;</span>, likeClick.getLongAccumulator(), timer.intervalRestart());<br>threadPool.shutdown();<br></code></pre></td></tr></table></figure>
<p>结果：<br>
<img src="https://fastly.img.kedr.cc/ffa48f749bfea7c80b52ead2d578ad6b.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="LongAdder类原理解析"><a class="header-anchor" href="#LongAdder类原理解析"></a>LongAdder类原理解析</h4>
<p>继承体系图：</p>
<p><img src="https://fastly.img.kedr.cc/6f30c1fa745015694d4c7a5bfcf3cce0.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>Striped64类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Striped64</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> &#123;<br>    <br>    <span class="hljs-comment">/** Number of CPUS, to place bound on table size CPU数量，cells数组的最大长度  */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NCPU</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Table of cells. When non-null, size is a power of 2.</span><br><span class="hljs-comment">     * cells数组，长度是2的幂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Base value, used mainly when there is no contention, but also as</span><br><span class="hljs-comment">     * a fallback during table initialization races. Updated via CAS.</span><br><span class="hljs-comment">     * 基础value值，当并发较低时，只累加该值，主要用于没有竞争的情况，通过cas更新</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Spinlock (locked via CAS) used when resizing and/or creating Cells.</span><br><span class="hljs-comment">     * 在调整单元格大小和/或创建单元格时使用自旋锁（通过 CAS 锁定）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Cell内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>    Cell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> cmp, <span class="hljs-type">long</span> val)</span> &#123;<br>        <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, cmp, val);<br>    &#125;<br>    <span class="hljs-comment">// Unsafe mechanics</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            UNSAFE = sun.misc.Unsafe.getUnsafe();<br>            Class&lt;?&gt; ak = Cell.class;<br>            valueOffset = UNSAFE.objectFieldOffset<br>                (ak.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>LongAdder的基本思路就是<code>分散热点</code>，将value值分散个一个<code>Cell数组</code>中，不同线程会命中到数据的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，如此热点就被分散了，冲突的概率就会减小很多。当获取真正的long值时，将各个槽的变量值累加返回。</p>
<h5 id="基本原理"><a class="header-anchor" href="#基本原理"></a>基本原理</h5>
<p>LongAdder在无竞争的情况下和AtomicLong一样，对<code>base</code>变量进行cas操作。当出现竞争关系时采用<code>分散热点</code>的方式，用空间换时间，用一个<code>cells数组</code>，将一个value拆分进这个数组。多线程需要同时对value进行操作时，可以对线程id进行hash得到hash值，再根据hash值映射到这个cells数组的某个下标，再对该下标锁对应的值进行自增操作。当所有线程操作完毕，将cells数组的所有值和base都加起来作为最终结果。</p>
<h5 id="源码解析"><a class="header-anchor" href="#源码解析"></a>源码解析</h5>
<ul>
<li>
<p>add方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;<br>    <span class="hljs-comment">// as为cells</span><br>    <span class="hljs-comment">// b为base值</span><br>    <span class="hljs-comment">// v为期望值</span><br>    <span class="hljs-comment">// m为cells数组长度</span><br>    <span class="hljs-comment">// a为当前线程对应cell</span><br>    Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;<br>    <span class="hljs-comment">// 进入if语句的条件：cells不为空或casBase操作失败（说明出现了竞争情况）</span><br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-comment">// 判断是否出现冲突的标识符，出现冲突后可能要扩容</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 进入if语句调用longAccumulate的条件</span><br>        <span class="hljs-comment">// cells为空，创建一个长度为2的cells数组</span><br>        <span class="hljs-comment">// 数组长度小于0，不太可能出现</span><br>        <span class="hljs-comment">// 通过getProbe方法获取线程hash值，再计算得到线程对应cells数组的下标，获取线程对应数组中的cell，cell为空，说明当前线程还没有更新过cell，需要初始化cell</span><br>        <span class="hljs-comment">// cell中进行cas操作出现冲突，可能需要扩容</span><br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            !(uncontended = a.cas(v = a.value, v + x)))<br>            <span class="hljs-comment">// 调用Striped64中的longAccumulate方法</span><br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>longAccumulate方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longAccumulate</span><span class="hljs-params">(<span class="hljs-type">long</span> x, LongBinaryOperator fn,</span><br><span class="hljs-params">                          <span class="hljs-type">boolean</span> wasUncontended)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>   	<span class="hljs-comment">// 随机数未初始化</span><br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 强制初始化随机数</span><br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        <span class="hljs-comment">// 获取当前线程hash值</span><br>        h = getProbe();<br>        wasUncontended = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否需要扩容的标志</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">collide</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br>        <span class="hljs-comment">// cells数组已被初始化</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 线程对应数组中的cell，cell为空，说明当前线程还没有更新过cell，需要初始化cell</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    <span class="hljs-type">Cell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);   <span class="hljs-comment">// Optimistically create</span><br>                    <span class="hljs-comment">// 没有加锁并尝试加锁</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Cell[] rs; <span class="hljs-type">int</span> m, j;<br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                                (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<br>                                <span class="hljs-comment">// 将刚才new的cell放到数组对应下标</span><br>                                rs[j] = r;<br>                                created = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (created)<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                collide = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                <span class="hljs-comment">// 标记为没有竞争，重新获取hash值</span><br>                wasUncontended = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <span class="hljs-comment">// 调用cell的cas方法进行累加</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                                         fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 当前数组长度大于等于CPU数时不再扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                <span class="hljs-comment">// 设置为允许扩容</span><br>                collide = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 没有加锁并尝试加锁</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        <span class="hljs-comment">// 左移1位，即扩容为原长度的2倍</span><br>                        Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                collide = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>			<span class="hljs-comment">// 重新计算hash值</span><br>            h = advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">// cells没有加锁且没有初始化，尝试对它加锁，并初始化cells数组</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123;<br>                    Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 创建一个长度为2的数组</span><br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x); <span class="hljs-comment">// 将值放到线程对应下标位置</span><br>                    cells = rs;<br>                    init = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// cells正在进行初始化，则尝试直接在base上进行累加</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                                    fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://fastly.img.kedr.cc/0adc66e65a7047290078a79b07120975.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>sum方法，只保证最终一致性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>    Cell[] as = cells; Cell a;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ThreadLocal"><a class="header-anchor" href="#ThreadLocal"></a>ThreadLocal</h3>
<p>该类提供线程局部变量。 这些变量与它们的正常对应物的不同之处在于，访问其中的每个线程（通过其get或set方法）具有其<code>自己的，独立初始化</code>的变量副本。 ThreadLocal实例通常是希望将状态与线程相关联的类中的<code>私有静态字段</code>（例如，用户ID或事务ID）。</p>
<p>由于每个线程都有自己的变量副本，所以避免了线程安全问题。</p>
<p>在线程使用完成后最好调用ThreadLocal对象的remove方法，去删除此线程局部变量的当前线程值，避免影响后续业务逻辑和造成内存泄露等问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">objectThreadLocal.set(userInfo);<br><span class="hljs-keyword">try</span> &#123;<br> <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br> objectThreadLocal.remove();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Thread、ThreadLocal、ThreadLocalMap关系"><a class="header-anchor" href="#Thread、ThreadLocal、ThreadLocalMap关系"></a>Thread、ThreadLocal、ThreadLocalMap关系</h4>
<p>Thread类中包含ThreadLocal.ThreadLocalMap变量</p>
<p>ThreadLocalMap类是ThreadLocal类的静态内部类</p>
<p>ThreadLocalMap实际上就是一个以ThreadLocal实例为key，任意对象为value的Entry对象</p>
<h4 id="源码分析"><a class="header-anchor" href="#源码分析"></a>源码分析</h4>
<h5 id="ThreadLocal的get方法"><a class="header-anchor" href="#ThreadLocal的get方法"></a>ThreadLocal的get方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 获取线程的threadLocals变量</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 获取map中的值</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 未获取到时设置初始值</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="ThreadLocalMap类"><a class="header-anchor" href="#ThreadLocalMap类"></a>ThreadLocalMap类</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-built_in">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>ThreadLocalMap是以ThreadLocal为键的map，不过ThreadLocal是经过两层包装的</p>
<p>第一层使用WeakReference&lt;ThreadLocal&lt;?&gt;&gt;将ThreadLocal对象变为一个<code>弱引用对象</code></p>
<p>第二层是定义了一个Entry类来拓展WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</p>
<h5 id="各种引用"><a class="header-anchor" href="#各种引用"></a>各种引用</h5>
<p><img src="https://fastly.img.kedr.cc/9791e3b267cbd18f09cb173170c60c51.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>
<p>Reference：强引用</p>
<ul>
<li>
<p>垃圾回收永远不会强引用的对象</p>
</li>
<li>
<p>把一个对象赋给一个引用变量，这个引用变量就是一个强引用</p>
</li>
<li>
<p>强引用是造成Java内存泄露的主要原因之一</p>
</li>
<li>
<p>当一个对象不再使用，可以将引用赋值为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyObj</span> <span class="hljs-variable">myObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObj</span>();<br>log.info(<span class="hljs-string">&quot;before gc &#123;&#125;&quot;</span>, myObj);<br>myObj = <span class="hljs-literal">null</span>;<br>System.gc();<br>log.info(<span class="hljs-string">&quot;after gc &#123;&#125;&quot;</span>, myObj);<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>SoftReference：软引用</p>
<ul>
<li>
<p>当系统内存充足时它不会被回收</p>
</li>
<li>
<p>当系统内存不足时它会被回收</p>
</li>
<li>
<p>需要用SoftReference类来实现</p>
</li>
<li>
<p>软引用通常用在对内存敏感的程序中，如高速缓存就用到软引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加JVM参数 -Xmx10m -Xms10m</span><br>SoftReference&lt;MyObj&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObj</span>());<br>System.gc();<br>log.info(<span class="hljs-string">&quot;after gc &#123;&#125;&quot;</span>, softReference.get());<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">20</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]; <span class="hljs-comment">// 20M对象</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    log.info(<span class="hljs-string">&quot;after gc &#123;&#125;&quot;</span>, softReference.get());<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>WeakReference：弱引用</p>
<ul>
<li>
<p>用WeakReference类来实现，它比软引用生命周期更短</p>
</li>
<li>
<p>对于弱引用的对象来说，只要一执行垃圾回收，不管JVM内存是否足够，都会回收该对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">WeakReference&lt;MyObj&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObj</span>());<br>log.info(<span class="hljs-string">&quot;before gc &#123;&#125;&quot;</span>, weakReference.get());<br>System.gc();<br>log.info(<span class="hljs-string">&quot;after gc &#123;&#125;&quot;</span>, weakReference.get());<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>PhantomReference：虚引用</p>
<ul>
<li>
<p>虚引用必须和ReferenceQueue（引用队列）联合使用</p>
</li>
<li>
<p>若对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收</p>
</li>
<li>
<p>get方法总是返回null</p>
</li>
<li>
<p>虚引用的主要作用是跟踪对象被垃圾回收的状态，仅仅提供了一种确保对象被<code>finalize以后</code>，做某些事情的通知机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyObj</span> <span class="hljs-variable">myObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObj</span>();<br>ReferenceQueue&lt;MyObj&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>PhantomReference&lt;MyObj&gt; phantomReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(myObj, referenceQueue);<br>log.info(<span class="hljs-string">&quot;phantomReference.get() &#123;&#125;&quot;</span>, phantomReference.get());<br>List&lt;<span class="hljs-type">byte</span>[]&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        data.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">1</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;add 1m to data, phantomReference.get() &#123;&#125;&quot;</span>, phantomReference.get());<br>    &#125;<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyObj</span>&gt; reference = referenceQueue.poll();<br>        <span class="hljs-keyword">if</span> (reference != <span class="hljs-literal">null</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;虚对象被回收加入了引用队列 &#123;&#125;&quot;</span>, reference.get());<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>软引用和弱引用的适用场景</p>
<ul>
<li>图片缓存：程序需要读取大量本地图片，若每次都从硬盘读取会严重影响性能，若一次性全部加载到内存又可能造成内存溢出，此时可以用软引用来解决这个问题
<ul>
<li>用一个Map保存图片路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间</li>
<li>Map&lt;String, SoftReference&lt;BufferedImage&gt;&gt; imgCache = new HashMap&lt;&gt;();</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="为什么用弱引用作为键"><a class="header-anchor" href="#为什么用弱引用作为键"></a>为什么用弱引用作为键</h5>
<p>若键的引用是强引用，就会导致键指向的ThreadLocal对象以及值指向的对象不能被垃圾回收，造成内存泄漏</p>
<p>若键的引用是弱引用就大概率会减少内存泄漏的问题</p>
<p>垃圾回收后键的引用会指向null，这是就会出现一个键为null的Entry，并且无法访问到这个键对应的值，若当前线程迟迟不结束的话，这些键为null的Entry就会一直存在一条强引用链，无法回收，造成内存泄漏；若线程运行结束，就没有引用链可达了，在垃圾回收时就会被回收</p>
<p>在实际开发中，会使用线程池去复用线程，这样线程是不会结束的；可见弱引用不能100%保证内存不泄露，所以在不使用某个ThreadLocal对象后，手动调用remove方法来删除它</p>
<h5 id="ThreadLocalMap的expungeStaleEntry方法"><a class="header-anchor" href="#ThreadLocalMap的expungeStaleEntry方法"></a>ThreadLocalMap的expungeStaleEntry方法</h5>
<p>当键为null时调用set、get、remove方法最后都会调用expungeStaleEntry方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">// expunge entry at staleSlot</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 当键的引用为null时，将值的引用指向null，方便垃圾回收</span><br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span><br>                <span class="hljs-comment">// null because multiple entries could have been stale.</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="最佳实践"><a class="header-anchor" href="#最佳实践"></a>最佳实践</h4>
<ul>
<li>使用 ThreadLocal.withInitial(Supplier s)方式给一个初始值，防止出现NPE</li>
<li>建议将ThreadLocal变量用static修饰</li>
<li>使用完成手动调用remove，避免内存泄漏</li>
</ul>
<h3 id="Java内存对象布局和对象头"><a class="header-anchor" href="#Java内存对象布局和对象头"></a>Java内存对象布局和对象头</h3>
<h4 id="创建对象的过程"><a class="header-anchor" href="#创建对象的过程"></a>创建对象的过程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>Object.class在方法区</li>
<li>o引用在栈</li>
<li>new Object()在堆</li>
</ul>
<p>在HotSpot虚拟机中，对象在堆内存中存储布局可以分为三个部分：</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<p><img src="https://fastly.img.kedr.cc/9fb0a4668ffc630313ea7189cc68c886.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://fastly.img.kedr.cc/9814df7ccdc64f8d9275d823503631b7.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="对象头"><a class="header-anchor" href="#对象头"></a>对象头</h4>
<ul>
<li>对象头由对象标记（Mark Word）、类元信息（又叫类型指针）构成</li>
<li>对象标记包含以下信息
<ul>
<li>哈希码</li>
<li>GC标记</li>
<li>GC次数</li>
<li>同步锁标记</li>
<li>偏向锁持有者</li>
</ul>
</li>
<li>类元信息存储的是指向该对象类元数据的首地址（指向方法区中的地址）</li>
</ul>
<h5 id="对象标记"><a class="header-anchor" href="#对象标记"></a>对象标记</h5>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象哈希码、对象分代年龄</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空，不需要记录信息</td>
<td>11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody>
</table>
<p>在64位系统中，对象标记占了<code>8个字节</code>，类型指针占了<code>8个字节</code>，对象头一共<code>16字节</code></p>
<p>对象标记用于存储对象的hashcode、分代年龄和锁标志位等信息</p>
<p>这些信息都是与对象自身定义无关的数据，所以对象标记被设计成一个非固定数据结构的以便在极小的空间内存储尽量多的数据，它会根据对象的状态复用自己的存储空间，即在运行期间对象标记里存储的数据会随着锁标志位的变化而变化</p>
<p><img src="https://fastly.img.kedr.cc/d3bc2d7c23f9f3c34b21ffc9641ec517.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h5 id="类型指针"><a class="header-anchor" href="#类型指针"></a>类型指针</h5>
<p>类型指针存储的是指向该对象类元数据的首地址</p>
<p>类型指针占了<code>8个字节</code></p>
<h4 id="实例数据"><a class="header-anchor" href="#实例数据"></a>实例数据</h4>
<p>存储类的属性（Field）信息，包括父类的属性信息</p>
<h4 id="对齐填充"><a class="header-anchor" href="#对齐填充"></a>对齐填充</h4>
<p>虚拟机要求对象起始地址必须是<code>8字节的整数倍</code>，填充数据不是必须存在的，仅仅是为了字节对齐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Custom</span> &#123; <span class="hljs-comment">// 对象头16字节（忽略压缩指针的影响）+4字节+1字节=21字节，对齐填充到24字节</span><br>    <span class="hljs-type">int</span> id; <span class="hljs-comment">// 4字节</span><br>    <span class="hljs-type">boolean</span> flag; <span class="hljs-comment">// 1字节</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="使用JOL分析对象在JVM中的大小和布局"><a class="header-anchor" href="#使用JOL分析对象在JVM中的大小和布局"></a>使用JOL分析对象在JVM中的大小和布局</h4>
<p>pom中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// VM的细节详细情况</span><br><span class="hljs-comment">// System.out.println(VM.current().details());</span><br><span class="hljs-comment">// 所有对象分配的字节都是8的整数倍</span><br><span class="hljs-comment">// System.out.println(VM.current().objectAlignment());</span><br><br><span class="hljs-comment">// 对象的内存布局</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(ClassLayout.parseInstance(o).toPrintable());<br></code></pre></td></tr></table></figure>
<p><img src="https://fastly.img.kedr.cc/8450e4cd5358bb0610f5f43b88d4df79.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Custom</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Custom</span>();<br>System.out.println(ClassLayout.parseInstance(c).toPrintable());<br></code></pre></td></tr></table></figure>
<p><img src="https://fastly.img.kedr.cc/606284664ad0d3d82382d647ab6c8891.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>类型指针为4字节与预期不一致是因为JVM默认开启了压缩指针</p>
<p>加上<code>-XX:+PrintCommandLineFlags</code>参数查看JVM默认添加的参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">-XX:InitialHeapSize=267278208 -XX:MaxHeapSize=4276451328 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC<br></code></pre></td></tr></table></figure>
<p>其中<code>-XX:+UseCompressedClassPointers</code>为开启了压缩指针，<code>+</code>为开启，<code>-</code>为关闭</p>
<p>启动时加上<code>-XX:-UseCompressedClassPointers</code>参数关闭压缩指针</p>
<p><img src="https://fastly.img.kedr.cc/9b3f207bf44f7cfa4cb5070dc169c768.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="Synchronized与锁升级"><a class="header-anchor" href="#Synchronized与锁升级"></a>Synchronized与锁升级</h3>
<h4 id="锁的升级过程"><a class="header-anchor" href="#锁的升级过程"></a>锁的升级过程</h4>
<p>用锁能实现数据的安全性，但是会带来性能下降</p>
<p>无锁能够基于线程并行提升程序性能，但会带来安全性下降</p>
<p>锁的升级顺序：</p>
<pre><code class=" mermaid">flowchart LR
	node1(无锁) --&gt; node2(偏向锁) --&gt; node3(轻量级锁) --&gt; node4(重量级锁)
</code></pre>
<p>根据对象标记中标识位的不同表示不同锁</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>偏向锁位</th>
<th>锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>无锁</td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td></td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td></td>
<td>10</td>
</tr>
</tbody>
</table>
<p>对象标记中除了标识位还记录的内容：</p>
<ul>
<li>偏向锁：存储的是偏向的线程ID</li>
<li>轻量级锁：存储的是指向线程<code>栈中Lock Record</code>的指针</li>
<li>重量级锁：存储的是指向<code>堆中的监视器对象</code>的指针</li>
</ul>
<p>Java5之前，使用synchronized这个重量级锁，当竞争激烈时，性能会下降。若要阻塞或唤醒一个线程就需要操作系统介入，需要在用户态和内核态之间频繁切换，这种切换会消耗大量系统资源。</p>
<p>在Java早期版本中，synchronized属于重量级锁，效率低，因为监视器锁是依赖底层操作系统的<code>系统互斥量（Mutex Lock）</code>来实现的，线程的挂起和恢复都需要转入内核态去完成。</p>
<p>Java6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁</p>
<h4 id="无锁"><a class="header-anchor" href="#无锁"></a>无锁</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// 对象没有调用前没有生成hashcode</span><br>System.out.println(<span class="hljs-string">&quot;10进制hashcode: &quot;</span> + o.hashCode());<br>System.out.println(<span class="hljs-string">&quot;16进制hashcode: &quot;</span> + Integer.toHexString(o.hashCode()));<br>System.out.println(<span class="hljs-string">&quot;2进制hashcode: &quot;</span> + Integer.toBinaryString(o.hashCode()));<br>System.out.println(ClassLayout.parseInstance(o).toPrintable());<br></code></pre></td></tr></table></figure>
<p><img src="https://fastly.img.kedr.cc/b76a48e48ad6a73f726487b13992e4da.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="偏向锁"><a class="header-anchor" href="#偏向锁"></a>偏向锁</h4>
<p>单线程竞争</p>
<p>当线程第一次竞争到锁时，通过操作修改对象标记中的偏向线程ID、偏向模式</p>
<p>若不存在其他线程竞争，那么持有偏向锁的线程将<code>永远不需要进行同步</code></p>
<p>即当一段同步代码一直被同一个线程多次访问后，由于只有一个线程那么该线程在后续访问时便会自动获得偏向锁</p>
<p>也就是说锁总是被第一个占用它的线程拥有，这个线程就是锁的<code>偏向线程</code></p>
<h5 id="流程分析"><a class="header-anchor" href="#流程分析"></a>流程分析</h5>
<p>在锁第一次被持有时记录下偏向线程ID，偏向线程就一直持有着锁（后续这个线程进入或退出同步锁的代码块时，不再需要加锁和释放锁操作，而是直接去检查锁的对象标记中是不是存放着自己的线程ID）</p>
<p>判断偏向锁的对象标记中的线程ID与当前线程ID相等时，表示当前线程是偏向锁的偏向线程，直接进入同步，无需每次加锁解锁都去CAS更新对象头，若始终只有一个线程使用锁，很明显偏向锁几乎没有额外开销，性能极高</p>
<p>当不相等时，表示发生了竞争，会尝试使用CAS来替换对象标记里的线程ID为当前线程ID</p>
<p>若竞争成功，对象标记里的线程ID更新为当前线程ID，锁不会升级，依然是偏向锁，只是偏向线程变更了</p>
<p>若竞争失败，这时可能需要升级为轻量锁，才能保证线程间公平竞争锁</p>
<h5 id="偏向锁相关VM参数"><a class="header-anchor" href="#偏向锁相关VM参数"></a>偏向锁相关VM参数</h5>
<p>使用命令<code>java -XX:+PrintFlagsInitial | grep BiasedLock*</code> 查看偏向锁相关参数</p>
<p><img src="https://fastly.img.kedr.cc/b484c8fd38c390ac642186727fcb589e.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>代码示例</p>
<p>添加VM参数<code>-XX:BiasedLockingStartupDelay=0</code>，将偏向锁启动延时时间设置为0</p>
<p>也可以不加这个参数，可以在代码里面手动延时超过4s</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span> (o) &#123;<br>    System.out.println(ClassLayout.parseInstance(o).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://fastly.img.kedr.cc/7f6a79f529eb6539400b8d91f39338e1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h5 id="偏向锁的撤销"><a class="header-anchor" href="#偏向锁的撤销"></a>偏向锁的撤销</h5>
<p>偏向锁是一种等到竞争出现才会释放锁的机制</p>
<p>撤销需要等待<code>全局安全点</code>（该时间点上没有字节码正在执行），同时检查持有偏向锁的线程是否还在执行</p>
<p>若线程正在执行（处于同步代码块），它没执行完，其他线程来竞争，该偏向锁会被撤销并出现<code>锁升级</code>，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码块，而正在竞争的线程会进入自旋等待获得该轻量级锁</p>
<p>若线程执行完成（退出同步代码块），则将对象标记设置为无锁状态并撤销偏向锁，重新偏向</p>
<h4 id="轻量级锁"><a class="header-anchor" href="#轻量级锁"></a>轻量级锁</h4>
<p>多线程竞争，但是任意时刻最多只有一个线程竞争，即不存在锁竞争太过激烈的情况，也就是没有线程阻塞</p>
<p>本质就是<code>自旋锁CAS</code></p>
<h5 id="轻量级锁的加锁"><a class="header-anchor" href="#轻量级锁的加锁"></a>轻量级锁的加锁</h5>
<p>JVM为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，称为Displaced Mark Word</p>
<p>若线程获得锁时发现是轻量级锁，会把锁的对象标记复制到自己的DMW里面</p>
<p>然后线程尝试用CAS将锁的对象标记替换为指向锁记录的指针，若成功，则当前线程获得锁，若失败，说明在与其他线程竞争锁，当前线程就尝试使用自旋来获取锁</p>
<p>自旋CAS操作，不断尝试去获取锁，能不升级锁就不升级，尽量不要阻塞</p>
<h5 id="轻量级锁的释放"><a class="header-anchor" href="#轻量级锁的释放"></a>轻量级锁的释放</h5>
<p>在释放锁时，线程会使用CAS操作将Displaced Mark Word的内容复制回锁的对象标记里</p>
<p>若没有发生竞争，那么复制操作成功</p>
<p>若有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程</p>
<h5 id="代码示例"><a class="header-anchor" href="#代码示例"></a>代码示例</h5>
<p>添加VM参数<code>-XX:-UseBiasedLocking</code>，关闭偏向锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (o) &#123;<br>        System.out.println(ClassLayout.parseInstance(o).toPrintable());<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<h5 id="自旋达到一定次数"><a class="header-anchor" href="#自旋达到一定次数"></a>自旋达到一定次数</h5>
<p>会升级为重量级锁</p>
<ul>
<li>Java6之前
<ul>
<li>默认情况下自旋的次数超过10次（可以通过-XX:PreBlockSpin=10来修改）</li>
<li>或者自旋线程数超过CPU核数一半</li>
</ul>
</li>
<li>Java6之后
<ul>
<li>自适应自旋锁（自旋的次数不固定）</li>
<li>若自旋后竞争成功了，那么下次自旋的最大次数会增加</li>
<li>若很少会自旋成功，那么下次会减少自旋的次数甚至不自旋，避免CPU空转</li>
</ul>
</li>
</ul>
<h5 id="与偏向锁的区别"><a class="header-anchor" href="#与偏向锁的区别"></a>与偏向锁的区别</h5>
<ul>
<li>偏向锁没有竞争</li>
<li>竞争轻量级锁失败时，自旋尝试抢占锁</li>
<li>轻量级锁每次退出同步块是都需要释放锁，而偏向锁是在竞争发生时才释放锁</li>
</ul>
<h4 id="重量级锁"><a class="header-anchor" href="#重量级锁"></a>重量级锁</h4>
<p>通过monitorenter、monitorexit等指令来操作监视器对象实现</p>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (o) &#123;<br>        System.out.println(ClassLayout.parseInstance(o).toPrintable());<br>    &#125;<br>&#125;).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (o) &#123;<br>        System.out.println(ClassLayout.parseInstance(o).toPrintable());<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<h4 id="总结"><a class="header-anchor" href="#总结"></a>总结</h4>
<h5 id="完整流程图"><a class="header-anchor" href="#完整流程图"></a>完整流程图</h5>
<p><img src="https://fastly.img.kedr.cc/e32f7c934a75deec3cfbe4fdc5fa1110.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h5 id="其他问题"><a class="header-anchor" href="#其他问题"></a>其他问题</h5>
<p>无锁状态下，对象标记中记录了hashcode，为什么锁升级后就没了？</p>
<blockquote>
<p>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了，跳过偏向锁，直接升级为轻量级锁</p>
<p>而当一个对象处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁膨胀为重量级锁</p>
<p>升级为轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录（Lock Record）空间，用于存储锁对象的对象标记拷贝，释放锁时将这些信息写回到对象头</p>
<p>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态下的对象标记，其中自然可以存储原来的哈希码</p>
</blockquote>
<h5 id="其他小结"><a class="header-anchor" href="#其他小结"></a>其他小结</h5>
<p>synchronized锁升级过程总结：先自旋，不行再阻塞</p>
<p>实际上是把之前悲观锁（重量级锁）变成在一定条件下使用偏向锁以及使用轻量级锁（自旋锁CAS）的形式</p>
<p>适用情况：</p>
<ul>
<li>偏向锁：适用于单线程情况，不存在锁竞争时</li>
<li>轻量级锁：适用于竞争不激烈的情况，若同步方法/同步代码块执行时间很短的话，采用轻量级锁虽然会占用CPU资源但是相对比使用重量级锁还是更高效</li>
<li>重量级锁：适用于竞争激烈的情况，若同步方法/同步代码块执行时间长，那么使用轻量级锁带来的性能消耗就比使用重量级锁更严重，这时就需要升级为重量级锁</li>
</ul>
<h4 id="JIT编译器对锁的优化"><a class="header-anchor" href="#JIT编译器对锁的优化"></a>JIT编译器对锁的优化</h4>
<p>JIT一般被称为即时编译器（Just In Time Compiler）</p>
<h5 id="锁消除"><a class="header-anchor" href="#锁消除"></a>锁消除</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">// 锁加的没有意义，JIT编译器会无视它</span><br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        System.out.println(obj.hashCode());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">LockClearDemo</span> <span class="hljs-variable">clearDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockClearDemo</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            clearDemo.m1();<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="锁粗化"><a class="header-anchor" href="#锁粗化"></a>锁粗化</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>        &#125;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>JIT编译器会将多个首尾相连且相同锁的同步代码块合并</p>
<h3 id="AQS"><a class="header-anchor" href="#AQS"></a>AQS</h3>
<p>全称为AbstractQueuedSynchronizer，抽象的队列同步器</p>
<p>是用来实现锁或者其他同步器组件的公共基础部分的抽象实现</p>
<p>是重量级基础框架及整个JUC体系的基石，主要用于解决锁分配给谁的问题</p>
<p>整体就是一个抽象的FIFO队列（CLH队列的变体）来完成资源获取线程的排队工作，并通过一个volatile int类变量表示持有锁的状态</p>
<p>CountDownLatch、Semaphore、CyclicBarrier、ReentrantLock、ReentrantReadWriteLock等类的实现都与AQS有关</p>
<h4 id="源码说明"><a class="header-anchor" href="#源码说明"></a>源码说明</h4>
<p>AQS使用一个volatile int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-comment">// 共享模式</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-comment">// 排他模式</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">/** 线程已取消 */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/** 后继线程需要唤醒 */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/** 等待条件唤醒 */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">/** 下一个acquireShared将会无条件传播下去 */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 节点的等待状态，状态有上面4种</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>        <span class="hljs-comment">// 前驱节点</span><br>        <span class="hljs-keyword">volatile</span> Node prev;<br>        <span class="hljs-comment">// 后继节点</span><br>        <span class="hljs-keyword">volatile</span> Node next;<br>        <span class="hljs-comment">// 处于该节点的线程</span><br>        <span class="hljs-keyword">volatile</span> Thread thread;<br>        <span class="hljs-comment">// 指向下一个处于condition状态的节点</span><br>        Node nextWaiter;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 队列头结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br>    <span class="hljs-comment">// 队列尾结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br>    <span class="hljs-comment">// 队列同步状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br>    <span class="hljs-comment">// ...</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://fastly.img.kedr.cc/a0b5cbc383da7dbf072357cbb6c76042.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="ReentrantLock原理"><a class="header-anchor" href="#ReentrantLock原理"></a>ReentrantLock原理</h4>
<p><img src="https://fastly.img.kedr.cc/030f4a80963b24c2284c852ada08ff6b.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>ReentrantLock底层也是通过AQS实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用无参构造 默认为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="lock和acquire"><a class="header-anchor" href="#lock和acquire"></a>lock和acquire</h5>
<pre><code class=" mermaid">flowchart LR
	lock(lock) --&gt; acquire(acquire) --&gt; tryAcquire(tryAcquire)
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FairSync</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    acquire(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// NonfairSync</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 先CAS操作</span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// AQS</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// !tryAcquire 尝试获取资源失败</span><br>    <span class="hljs-comment">// addWaiter 将当前线程封装成Node节点，并添加到同步队列尾部</span><br>    <span class="hljs-comment">// acquireQueued 将获取资源失败的线程加入到同步队列中，并阻塞线程</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><span class="hljs-comment">// FairSync</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 获取队列同步器状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 没有等待的节点排在当前线程节点前面</span><br>        <span class="hljs-comment">// 且CAS操作成功</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// NonfairSync</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>&#125;<br><span class="hljs-comment">// Sync</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 比公平锁少了一个判断前面是否有等待节点的条件</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="tryAcquire"><a class="header-anchor" href="#tryAcquire"></a>tryAcquire</h5>
<p>以非公平锁为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><span class="hljs-comment">// NonfairSync</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>&#125;<br><span class="hljs-comment">// Sync</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">// 判断队列同步器状态是否为空</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 竞争资源</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            <span class="hljs-comment">// 将同步器持有线程设置为当前线程</span><br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断同步器持有线程是否为当前线程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-comment">// 同步器状态累加</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 竞争失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="addWaiter"><a class="header-anchor" href="#addWaiter"></a>addWaiter</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 创建一个排他模式节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-comment">// 前驱节点为同步器队列的队尾节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 将队尾结点设置为当前节点的前驱节点</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// 将当前节点设置为队尾结点</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 将原队尾结点的后继节点设置为当前节点</span><br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 队尾节点为空（表示队列未初始化）时执行</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 队尾节点引用</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">// 初始化队头节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                <span class="hljs-comment">// 将队尾节点页指向刚创建的队头节点</span><br>                tail = head;<br>            <span class="hljs-comment">// 也就是说如论如何都会都有一个哨兵节点作为队头节点，只是占位，不存储任何信息</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 将队尾结点设置为当前节点的前驱节点</span><br>            node.prev = t;<br>            <span class="hljs-comment">// 将当前节点设置为队尾结点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                <span class="hljs-comment">// 将原队尾结点的后继节点设置为当前节点</span><br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="acquireQueued"><a class="header-anchor" href="#acquireQueued"></a>acquireQueued</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 获取前驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 若前驱节点为队头节点就尝试竞争</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 竞争到资源 将当前节点设置为队头节点</span><br>                setHead(node);<br>                <span class="hljs-comment">// 原队头节点出队</span><br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 前驱节点不为队头节点或竞争失败</span><br>            <span class="hljs-comment">// 根据前驱节点的状态判断是否需要在竞争失败后阻塞当前线程</span><br>            <span class="hljs-comment">// 执行阻塞当前线程（LockSupport.park）并返回线程是否被中断（阻塞后被唤醒才返回）</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            <span class="hljs-comment">// 若失败，取消竞争</span><br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-comment">// 前驱节点状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将前驱节点的状态改为signal</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 线程阻塞在这</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// 唤醒后返回线程中断状态并清除中断标志位</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="unlock和release"><a class="header-anchor" href="#unlock和release"></a>unlock和release</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// AQS</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 判断队头节点不为空且队头节点状态不为0</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// Sync</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">// 变更同步器状态</span><br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br><span class="hljs-comment">// AQS</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 将节点状态变更为0</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 获取后继节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 唤醒后继节点</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="cancelAcquire"><a class="header-anchor" href="#cancelAcquire"></a>cancelAcquire</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    node.thread = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// Skip cancelled predecessors</span><br>    <span class="hljs-comment">// 跳过取消状态的前驱节点（一直往前找到第一个状态不为取消的节点作为前驱节点）</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>        node.prev = pred = pred.prev;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br>    <span class="hljs-comment">// 当前节点状态变更为取消状态</span><br>    node.waitStatus = Node.CANCELLED;<br>    <span class="hljs-comment">// 若当前节点为队尾节点 将队尾节点设置为前驱节点</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>        <span class="hljs-comment">// 将前驱节点的后续节点设置为null</span><br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> ws;<br>        <span class="hljs-comment">// 前驱节点不为队头节点</span><br>        <span class="hljs-comment">// 前驱节点状态为signal 不然就把前驱节点状态变更为signal</span><br>        <span class="hljs-comment">// 前驱节点持有线程不为空（不为哨兵节点）</span><br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// 将前驱节点的后续节点设置为当前节点的后续节点</span><br>                compareAndSetNext(pred, predNext, next);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            unparkSuccessor(node);<br>        &#125;<br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="总结-v2"><a class="header-anchor" href="#总结-v2"></a>总结</h5>
<p>ReentrantLock加锁过程可以分为三个阶段：</p>
<ul>
<li>尝试加锁</li>
<li>加锁失败，线程入队列</li>
<li>线程入队列后，进入阻塞状态</li>
</ul>
<p><img src="https://fastly.img.kedr.cc/9a98d6fe57a26ec06102921260577fa0.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="其他锁"><a class="header-anchor" href="#其他锁"></a>其他锁</h3>
<pre><code class=" mermaid">flowchart LR
	node1(无锁) --&gt; node2(独占锁) --&gt; node3(读写锁) --&gt; node4(邮戳锁)
</code></pre>
<p>独占锁包括synchronized关键字以及Lock接口实现类如ReentrantLock等锁，每次都只允许一个线程进行读写操作</p>
<h4 id="ReentrantReadWriteLock"><a class="header-anchor" href="#ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4>
<p>可重入读写锁，一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。即<code>读写互斥，读读共享</code></p>
<p>适用于<code>读多写少</code>的场景</p>
<p>缺点：</p>
<ul>
<li>会造成写饥饿问题</li>
<li>会出现锁降级（写锁降级为读锁）
<ul>
<li>锁降级就是将写锁降级为读锁（类似于linux中的文件读写权限，写权限高于读权限），锁的严苛程度变强叫做升级，反之叫做降级</li>
<li>同一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁，此时就发生了锁降级，降级为了读锁；若释放了写锁，则完全转换为读锁</li>
<li>读锁无法升级为写锁，写锁必须在读锁释放后才能获取到</li>
<li>目的是为了让当前线程感知到数据的变化，目的是保证数据可见性（当前线程写完之后马上要读取，不希望被别的线程拿到写锁）</li>
</ul>
</li>
</ul>
<p><img src="https://fastly.img.kedr.cc/00c9280c7c91bca51acfa0efae458e54.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> lock.readLock();<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> lock.writeLock();<br>    writeLock.lock();<br>    log.info(<span class="hljs-string">&quot;写入&quot;</span>);<br>    readLock.lock();<br>    log.info(<span class="hljs-string">&quot;读取&quot;</span>);<br>    writeLock.unlock();<br>    readLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="StampedLock"><a class="header-anchor" href="#StampedLock"></a>StampedLock</h4>
<p>邮戳锁（也叫票据锁），是JDK1.8中新增的一个读写锁，是对JDK1.5中的读写锁ReentrantReadWriteLock的优化</p>
<p>主要是缓解ReentrantReadWriteLock的写锁饥饿问题</p>
<p>StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞</p>
<p><strong>在获取乐观读锁后，还需要对结果进行校验</strong></p>
<p>特点：</p>
<ul>
<li>所有获取锁的方法，都返回一个邮戳，邮戳为0表示获取失败，其余都表示成功</li>
<li>所有释放锁的方法，都需要传入一个邮戳，这个邮戳必须是和成功获取锁时得到的邮戳一致</li>
<li>StampedLock是<code>不可重入</code>的（若一个线程已经持有了写锁，再去获取写锁就会造成死锁）</li>
<li>StampedLock有三种访问模式
<ul>
<li>Reading：悲观读模式，功能和ReentrantReadWriteLock的读锁类似</li>
<li>Writing：写模式，功能和ReentrantReadWriteLock的写锁类似</li>
<li>Optimistic Reading：乐观读模式，无锁机制，类似于数据库中的乐观锁，支持读写并发，很乐观地认为读取时没有其他线程修改，若发现被修改再实现升级为悲观读模式</li>
</ul>
</li>
</ul>
<p><img src="https://fastly.img.kedr.cc/c0f4701627e1a20a8a3aa16dab8e4c99.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryOptimisticRead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> number;<br>    log.info(<span class="hljs-string">&quot;&#123;&#125; validate &#123;&#125;&quot;</span>, Thread.currentThread().getName(), lock.validate(stamp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">1</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; validate &#123;&#125;&quot;</span>, Thread.currentThread().getName(), lock.validate(stamp));<br>    &#125;<br>    <span class="hljs-comment">// 校验失败，升级为悲观读，重新读取</span><br>    <span class="hljs-keyword">if</span> (!lock.validate(stamp)) &#123;<br>        log.info(<span class="hljs-string">&quot;number has bean changed&quot;</span>);<br>        stamp = lock.readLock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            num = number;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlockRead(stamp);<br>        &#125;<br>    &#125;<br>    log.info(<span class="hljs-string">&quot;&#123;&#125; read &#123;&#125;&quot;</span>, Thread.currentThread().getName(), num);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">StampedLockDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLockDemo</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        demo.tryOptimisticRead();<br>    &#125;).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="hljs-number">2</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        demo.write();<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="https://fastly.img.kedr.cc/16e4df13f167f92bd52c85352d715309.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h5 id="使用注意事项"><a class="header-anchor" href="#使用注意事项"></a>使用注意事项</h5>
<ul>
<li>不支持重入</li>
<li>悲观读锁和写锁都不支持条件变量（Condition）</li>
<li>使用StampedLock一定不要调用中断操作（interrupt）</li>
</ul>
<h3 id="ConcurrentHashMap"><a class="header-anchor" href="#ConcurrentHashMap"></a>ConcurrentHashMap</h3>
<h4 id="sizeCtl变量的含义"><a class="header-anchor" href="#sizeCtl变量的含义"></a>sizeCtl变量的含义</h4>
<ul>
<li>0值：表示数组未初始化，且数组的初始容量为16</li>
<li>正数：若数组未初始化，表示值为数组的初始容量，若数组已初始化，则表示数组的扩容阈值（数组的容量*0.75）</li>
<li>-1：表示数组正在进行初始化</li>
<li>小于0且不是-1：表示数组正在扩容，-(n+1)，表示此时有n个线程同时进行数组的扩容</li>
</ul>
<h4 id="putVal"><a class="header-anchor" href="#putVal"></a>putVal</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 根据键对象的hashcode计算hash值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 不满足break条件就一直循环</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-comment">// 初始化数组</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <span class="hljs-comment">// hash值与数组长度-1取模，获得对应的下标，且当前数组下标位置没有元素</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// CAS操作，将new的节点放到数组下标位置</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-comment">// 数组下标位置的节点正在扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 将数组下标位置的节点加锁</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-comment">// 再次判断是否是数组下标位置的元素</span><br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">// hash值大于等于0为链表节点</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-comment">// hash值相等即hashcode相等且equals相等，返回旧值，更新为value</span><br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-comment">// 存在hash冲突，将节点挂到链表尾部</span><br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 是树节点</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-comment">// 将节点放到树结构中</span><br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 链表长度大于等于8</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    <span class="hljs-comment">// 判断是否满足树化条件（数组长度是否大于等于64），满足就将链表结构树化</span><br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 长度增加（逻辑与LongAdder相似，热点分散），判断是否需要扩容</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="initTable"><a class="header-anchor" href="#initTable"></a>initTable</h4>
<p>初始化数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-comment">// 若数组为null或长度为0进行初始化操作</span><br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 小于0表示当前正在进行初始化或者扩容操作</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 礼让其他线程</span><br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-comment">// CAS操作，将sizeCtl变量变更为-1状态</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 竞争成功，再次判断条件是否满足</span><br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 使用不为0的sizeCtl作为数组长度或者使用默认长度</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    <span class="hljs-comment">// 设置阈值为0.75*当前长度</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="addCount"><a class="header-anchor" href="#addCount"></a>addCount</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCount</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">int</span> check)</span> &#123;<br>    CounterCell[] as; <span class="hljs-type">long</span> b, s;<br>    <span class="hljs-comment">// counterCells不为空或者CAS更新baseCount失败</span><br>    <span class="hljs-comment">// 逻辑与LongAdder的add()方法基本一致</span><br>    <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-literal">null</span> ||<br>        !U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<br>        CounterCell a; <span class="hljs-type">long</span> v; <span class="hljs-type">int</span> m;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            !(uncontended =<br>              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;<br>            <span class="hljs-comment">// 逻辑与LongAdder的longAccumulate()方法基本一致</span><br>            fullAddCount(x, uncontended);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        s = sumCount();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-type">int</span> n, sc;<br>        <span class="hljs-comment">// 新baseCount值大于等于扩容阈值</span><br>        <span class="hljs-comment">// 数组不为空且长度小于允许的最大容量</span><br>        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-literal">null</span> &amp;&amp;<br>               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(n);<br>            <span class="hljs-comment">// 数组正在扩容</span><br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-literal">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-comment">// CAS操作，更新sizeCtl</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc,<br>                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-literal">null</span>);<br>            s = sumCount();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
        <a href="/tags/juc/" class="print-no-link">#juc</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JUC并发编程知识学习及查漏补缺</div>
      <div>https://blog.kedr.cc/posts/3956405114/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>zhuweitung</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年3月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/4034988835/" title="rclone+onedrive备份服务器">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">rclone+onedrive备份服务器</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/331375146/" title="k8s集群搭建">
                        <span class="hidden-mobile">k8s集群搭建</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"zhuweitung/zhuweitung.github.io","repo-id":"MDEwOlJlcG9zaXRvcnkzNjgxNjQ1MjM=","category":"Announcements","category-id":"DIC_kwDOFfG-q84CPNzk","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
          <script type="text/javascript" src="/js/cursor-effects.js"></script> <script color="0,0,0" opacity="0.5" zindex="-1" count="200" src="/js/canvas-nest.min.js"></script>
        </div>
      </div>
    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      浙ICP备2022018827号-1
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/custom.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
